using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using cAlgo.API;
using cAlgo.API.Collections;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using System.Text.Json;
using System.Text.Json.Serialization;


namespace cAlgo.Robots
{
    [Robot(AccessRights = AccessRights.FullAccess)]
    public class XAUUSD_StrategyLondonCtrader : Robot
    {

        [Parameter(DefaultValue = "Codigo de Usuario")]
        public string UserCode { get; set; }

        [Parameter("Hora de Inicio (NY)", DefaultValue = "03:00:00", Group = "Horario Operativo")]
        public string StartTimeString { get; set; }

        [Parameter("Hora de Fin (NY)", DefaultValue = "06:45:00", Group = "Horario Operativo")]
        public string EndTimeString { get; set; }

        [Parameter(DefaultValue = "Telegram Chat ID", Group = "Configuración de Telegram")]
        public string TelegramChatID { get; set; }

        [Parameter(DefaultValue = "Telegram API Token", Group = "Configuración de Telegram")]
        public string TelegramBotToken { get; set; }

        [Parameter(DefaultValue = "Monto a Arriesgar para operaciones en Compra")]
        public double amountToRiskBuy { get; set; }

        [Parameter(DefaultValue = "Monto a Arriesgar para operaciones en Venta")]
        public double amountToRiskSell { get; set; }

        // [Parameter(DefaultValue = "https://tradingbot-access.onrender.com", Group = "Configuración General (No Modificar)")]
        // public string BotAccessUrl { get; set; }

        // [Parameter(DefaultValue = "https://tradingview-alert-operator.onrender.com", Group = "Configuración General (No Modificar)")]
        // public string SignalUrl { get; set; }


        // API URLS
        private string BotAccessUrl = "https://tradingbot-access.onrender.com";
        private string SignalUrl = "https://tradingview-alert-operator.onrender.com";

        private DateTime lastTradeDate = DateTime.MinValue;

        private long openedPositionId = -1; // Variable para almacenar el ID de la posición abierta
        private string positionLabel = "";
        private TimeSpan startTime;
        private TimeSpan endTime;
        private double priceForBE = 0.0;
        private double amountToAddToSL = 0.75;

        protected override void OnStart()
        {
            // Tu código de inicialización aquí
            Print($"Account number: {Account.Number}");
            Print("Es real: ", Account.IsLive);
            SendTelegramMessage("INICIANDO TRADINGVIEW ALERT BOT EN CTRADER...");

            bool botAccessValidation = BotAccessValidation(Account.Number.ToString());

            if (!botAccessValidation)
            {
                SendTelegramMessage("Bot NO habilitado para esta cuenta");
                Stop();
            }

            foreach (var position in Positions)
            {
                if (position.SymbolName == SymbolName && position.EntryTime.Date == Server.Time.Date)
                {
                    Print("Ya existe una operación abierta para ", SymbolName, " en el día actual.");
                    break;
                }
            }

            startTime = TimeSpan.Parse(StartTimeString);
            endTime = TimeSpan.Parse(EndTimeString);
            
            // Ajustar al horario UTC según la diferencia horaria actual entre UTC y Nueva York
            int nyOffset = GetNyOffset();
            startTime = startTime.Add(TimeSpan.FromHours(nyOffset));
            endTime = endTime.Add(TimeSpan.FromHours(nyOffset));
            
            Print("Horario operativo ajustado a UTC: Inicio ", startTime, ", Fin ", endTime);
            
            double volume = CalculateVolumeForXAUUSDWithPips(amountToRiskBuy, 150.0);
            Print("VOLUME: ", volume);
            
            //var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, 150, positionLabel, 150.0, 300.0);
            // Obtiene los precios Ask y Bid actuales para el símbolo especificado
            double askPrice = Symbol.Ask;
            double bidPrice = Symbol.Bid;
            
            // Calcula el spread restando el Bid del Ask
            double spread = askPrice - bidPrice;
            
            // Convierte el spread a pips. El factor de conversión depende del símbolo
            // Para la mayoría de los pares de Forex, 1 pip = 0.0001, pero para pares con JPY es 0.01
            // Aquí se asume un factor de conversión estándar (1 pip = 0.0001)
            double spreadInPips = spread / Symbol.PipSize;
            
            Print("El spread actual para EURUSD es de ", spreadInPips, " pips.");

            SendTelegramMessage("¡INICIO DE BOT SATISFACTORIO!");
            //GetSignal();
        }

        protected override void OnTick()
        {
            // Handle price updates here
            // Obtiene la hora actual en UTC
            TimeSpan currentTime = Server.Time.TimeOfDay;
     
            if (!(currentTime >= startTime && currentTime <= endTime)  && openedPositionId == -1)
            {
                Print("Ya pasó horario operativo y no hay transacciones abiertas.");
            }
            else
            {
                GetSignal();
                return;
            }
        }

        protected override void OnStop()
        {
            // Handle cBot stop here
            SendTelegramMessage($"Bot apagado en la cuenta {Account.Number.ToString()} en CTrader!");
        }


        private void GetSignal()
        {
            int accountNumber = Account.Number;

            string url = $"{SignalUrl}/tradingview-alert-gold-london/signal/{UserCode}/{accountNumber.ToString()}/";

            var response = Http.Get(url);

            if (response.IsSuccessful)
            {
                var resultJson = JsonSerializer.Deserialize<SignalResponse>(response.Body);
                Print($"detail: {resultJson.detail}");
                Print($"signal_type: {resultJson.signal_type}");
                Print($"sl_price: {resultJson.sl_price}");
                Print($"tp_price: {resultJson.tp_price}");
                Print($"price_for_be: {resultJson.price_for_be}");
                Print($"set_be: {resultJson.set_be}");
                Print($"close_trade: {resultJson.close_trade}");
                double slPrice = resultJson.sl_price;
                double tpPrice = resultJson.tp_price;
                priceForBE = resultJson.price_for_be;
                bool openTrade = resultJson.detail;
                string signalType = resultJson.signal_type;
                bool closeTrade = resultJson.close_trade;
                bool set_be = resultJson.set_be;
                double slPips = resultJson.sl_pips;

                // Obtiene el valor de un pip para una onza de oro (XAUUSD) en la cuenta del usuario
                double pipValue = Symbols.GetSymbol(SymbolName).PipValue;

                if (openTrade)
                {
                    if (signalType == "buy" && !closeTrade){

                        if (openedPositionId == -1) // Abriremos compra porque llego señal y no es de orden de cerrar. Ademas no hay operacion abierta
                        {
                            // Obtiene el precio de entrada actual como el precio Ask para una operación de compra
                            double entryPrice = Symbols.GetSymbol(SymbolName).Ask;
                            double newSL = slPrice - amountToAddToSL;
                            double newSLPips = Math.Abs(entryPrice - newSL) / Symbol.PipSize; // Se pone newSL para ampliarlo en la operacion y evitar que se cierre antes de la alerta de Tradingview
                            double tpPips = Math.Abs(entryPrice - tpPrice) / Symbol.PipSize;

                            // Calcula el volumen necesario basado en el precio específico de SL
                            //double volume = CalculateVolumeForXAUUSDWithPrice(amountToRiskBuy, entryPrice, slPrice, pipValue);
                            double volume = CalculateVolumeForXAUUSDWithPips(amountToRiskBuy, slPips);
                            Print("entryPrice Compra para calculo de volumen: ", entryPrice);
                            Print("Volumen necesario: ", volume, " onzas");

                            positionLabel = "BUY OPENED";
                            var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, volume, positionLabel, newSLPips, tpPips); 

                            if (result.IsSuccessful)
                            {
                                openedPositionId = result.Position.Id;
                                double positionEntryPrice = result.Position.EntryPrice;
                                double positionTakeProfit = result.Position.TakeProfit ?? 0.0;
                                double positionStopLoss = result.Position.StopLoss ?? 0.0;
                                string telegramMessage = $@"[COMPRA] Precio Apertura: {positionEntryPrice}; PositionId: {openedPositionId}";
                                SendTelegramMessage(telegramMessage);
                            }
                            else 
                            {
                                Print($@"[COMPRA] Error al abrir operacion: {result.Error}");
                            }
                        }
                        else // Hay operacion abierta pero aun no hay señal de cierre, verificamos si ponemos BE
                        {
                            var position = Positions.Find(positionLabel);
                            if (set_be) 
                            {
                                var result = ModifyPosition(position, position.EntryPrice, position.TakeProfit);

                                if (result.IsSuccessful)
                                {
                                    string telegramMessage = $@"[COMPRA] Modificada operación a Breakeven: {position.EntryPrice}";
                                    SendTelegramMessage(telegramMessage);
                                }
                                else 
                                {
                                    Print($@"[COMPRA] Error colocando Breakeven: {result.Error}");
                                }
                            }
                        }
                        
                        
                    }
                    else if (signalType == "sell" && !closeTrade)
                    {
                        if (openedPositionId == -1) // Abriremos venta porque hay señal de venta y no es orden de cerrar. Ademas no hay operacion abierta
                        {
                            // Obtiene el precio de entrada actual como el precio Bid para una operación de venta
                            double entryPrice = Symbols.GetSymbol(SymbolName).Bid;
                            double newSL = slPrice - amountToAddToSL;
                            double newSLPips = Math.Abs(entryPrice - newSL) / Symbol.PipSize;
                            double tpPips = Math.Abs(entryPrice - tpPrice) / Symbol.PipSize;

                            // Calcula el volumen necesario basado en el precio específico de SL
                            //double volume = CalculateVolumeForXAUUSDWithPrice(amountToRiskSell, entryPrice, slPrice, pipValue);
                            double volume = CalculateVolumeForXAUUSDWithPips(amountToRiskSell, slPips);
                            Print("entryPrice Venta para calculo de volumen : ", entryPrice);
                            Print("Volumen necesario: ", volume, " onzas");
                            positionLabel = "SELL OPENED";
                            var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, volume, positionLabel, newSLPips, tpPips);

                            if (result.IsSuccessful)
                            {
                                openedPositionId = result.Position.Id;
                                double positionEntryPrice = result.Position.EntryPrice;
                                double positionTakeProfit = result.Position.TakeProfit ?? 0.0;
                                double positionStopLoss = result.Position.StopLoss ?? 0.0   ;
                                string telegramMessage = $@"[VENTA] Precio Apertura: {positionEntryPrice}; PositionId: {openedPositionId}";
                                SendTelegramMessage(telegramMessage);
                            }
                            else 
                            {
                                Print($@"[VENTA] Error al abrir operacion: {result.Error}");
                            }
                        }
                        else // Hay operacion abierta pero aun no hay señal de cierre, verificamos si ponemos BE
                        {   
                            var position = Positions.Find(positionLabel);
                            if (set_be) 
                            {
                                var result = ModifyPosition(position, position.EntryPrice, position.TakeProfit);

                                if (result.IsSuccessful)
                                {
                                    string telegramMessage = $@"[VENTA] Modificada operación a Breakeven: {position.EntryPrice}";
                                    SendTelegramMessage(telegramMessage);
                                }
                                else 
                                {
                                    Print($@"[VENTA] Error colocando Breakeven: {result.Error}");
                                }
                            }
                        }
                    }
                    else if (closeTrade && openedPositionId != -1) { // Si se manda a cerrar operacion
                        var position = Positions.Find(positionLabel);
                        if (position != null && position.Id == openedPositionId)
                        {
                            var result = ClosePosition(position);
                            if (result.IsSuccessful)
                            {
                                Print("Posición cerrada con éxito. ID: ", openedPositionId);
                                openedPositionId = -1; // Resetea el ID una vez que la posición se cierra
                                positionLabel = "";
                                priceForBE = 0.0;
                                string telegramMessage = "Se ha cerrado la operación";
                                SendTelegramMessage(telegramMessage);

                            }
                            else
                            {
                                Print("Error al cerrar la posición. ID: ", openedPositionId);
                            }
                        }
                    }

                }

                return ;
            }
        }
        
        public double CalculateVolumeForXAUUSDWithPips(double riskAmount, double slPips)
        {
            // Escala el número para preservar dos dígitos después del punto decimal
            double scaled = (riskAmount / slPips) * 100;
            
            // Trunca el número escalado para eliminar los dígitos después de los dos dígitos decimales
            double truncated = Math.Truncate(scaled);
            
            // Re-escala el número de vuelta a su tamaño original
            return truncated / 100;
        }

        public double CalculateVolumeForXAUUSDWithPrice(double riskAmount, double entryPrice, double slPrice, double pipValue)
        {
            // Calcula la diferencia entre el precio de entrada actual y el precio de stop loss
            double priceDifference = Math.Abs(entryPrice - slPrice);

            // Calcula el riesgo por pip
            // La diferencia de precio se convierte a pips dividiendo por el tamaño del pip (ej. 0.01 para XAUUSD)
            double riskPerPip = riskAmount / (priceDifference / Symbols.GetSymbol(SymbolName).PipSize);

            // Calcula el volumen necesario. El valor de pip aquí se asume por unidad (onza en caso de XAUUSD)
            double volumeInOunces = riskPerPip / pipValue;

            return Math.Round(volumeInOunces);
        }

        private void SendTelegramMessage(string message)
        {

            string url = $"https://api.telegram.org/bot{TelegramBotToken}/sendMessage?chat_id={TelegramChatID}&text={message}";

            var uri = new Uri(url);
            
            var postRequest = new HttpRequest(uri);

            postRequest.Method = HttpMethod.Post;

            var response = Http.Send(postRequest);

        }

        private bool BotAccessValidation(string accountNumber)
        {
            string url = $"{BotAccessUrl}/access-validation/{UserCode}/{accountNumber}/tradingview_alert_bot_enabled/";

            var response = Http.Get(url);

            if (response.IsSuccessful)
            {
                var resultJson = JsonSerializer.Deserialize<BotAccessResponse>(response.Body);
                Print($"ResultJson: {resultJson.result}");
                return resultJson.result;
            }
            return false;
        }

        private bool HasOpenedTradeToday(string symbol)
        {
            // Obtiene la fecha actual en UTC
            DateTime today = Server.Time.Date;

            // Itera a través de todas las posiciones abiertas
            foreach (var position in Positions)
            {
                // Verifica si la posición corresponde al símbolo objetivo y fue abierta hoy
                if (position.SymbolName== symbol && position.EntryTime.Date == today)
                {
                    return true; // Retorna verdadero si encuentra una coincidencia
                }
            }

            // Retorna falso si no se encuentra ninguna operación que coincida con los criterios
            return false;
        }

        // Esta función determina la diferencia horaria actual entre UTC y Nueva York
        private int GetNyOffset()
        {
            // Nueva York está en la zona horaria UTC-5 pero cambia a UTC-4 durante el horario de verano
            var nyTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
            var nyCurrentTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, nyTimeZoneInfo);
            return -nyTimeZoneInfo.GetUtcOffset(nyCurrentTime).Hours;
        }
    }

    public class BotAccessResponse
    {
        public bool result { get; set; }
    }

    public class SignalResponse
    {
        public bool detail { get; set; }
        public string signal_type { get; set; }
        public double sl_price { get; set; }
        public double sl_pips { get; set; }
        public double tp_price { get; set; }
        public double price_for_be { get; set; }
        public bool close_trade { get; set; }
        public bool set_be { get; set; }
    }
}