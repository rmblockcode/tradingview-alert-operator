using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using cAlgo.API;
using cAlgo.API.Collections;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Net;
using System.IO;

namespace cAlgo.Robots
{
    [Robot(AccessRights = AccessRights.FullAccess)]
    public class TradingViewAlertBotCtrader : Robot
    {

        [Parameter(DefaultValue = "Codigo de Usuario")]
        public string UserCode { get; set; }

        [Parameter(DefaultValue = "Telegram Chat ID", Group = "Configuración de Telegram")]
        public string TelegramChatID { get; set; }

        [Parameter(DefaultValue = "Telegram API Token", Group = "Configuración de Telegram")]
        public string TelegramBotToken { get; set; }

        //[Parameter(DefaultValue = "https://tradingbot-access.onrender.com", Group = "Configuración General (No Modificar)")]
        //public string BotAccessUrl { get; set; }

        //[Parameter(DefaultValue = "https://tradingview-alert-operator.onrender.com", Group = "Configuración General (No Modificar)")]
        //public string SignalUrl { get; set; }


        // API URLS
        private string BotAccessUrl = "https://tradingbot-access.onrender.com";
        private string SignalUrl = "https://tradingview-alert-operator.onrender.com";
        
        private string positionLabel = "";

        protected override void OnStart()
        {
            // Tu código de inicialización aquí
            Print($"Account number: {Account.Number}");
            Print("Es real: ", Account.IsLive);
            SendTelegramMessage("INICIANDO TRADINGVIEW ALERT BOT EN CTRADER...");

            bool botAccessValidation = BotAccessValidation(Account.Number.ToString());

            if (!botAccessValidation)
            {
                SendTelegramMessage("Bot NO habilitado para esta cuenta");
                Stop();
            }

            foreach (var position in Positions)
            {
                if (position.SymbolName == SymbolName && position.EntryTime.Date == Server.Time.Date)
                {
                    Print("Ya existe una operación abierta para ", SymbolName, " en el día actual.");
                    break;
                }
            }
            
            
            double slPips = 4.5;
            var symbol = Symbols.GetSymbol(SymbolName);
            double pipValue = symbol.PipValue;
            Print("pipValue: ", pipValue);
        
            double lotSize = CalculateLotSize(SymbolName, 150, slPips, 151.570);
            Print("lotSize: ", lotSize);
            double volume = Symbol.QuantityToVolumeInUnits(lotSize);
            Print("volume: ", volume);
            
            var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, volume, positionLabel, slPips, 0);

            SendTelegramMessage($"¡INICIO DE BOT SATISFACTORIO EN CUENTA {Account.Number}!");
            //GetSignal();
        }

        protected override void OnTick()
        {
            //GetSignal();
            return;
        }

        protected override void OnStop()
        {
            // Handle cBot stop here
            SendTelegramMessage($"Bot de Alertas desde Tradingview apagado en la cuenta {Account.Number} en CTrader!");
        }


        private void GetSignal()
        {
            int accountNumber = Account.Number;

            string url = $"{SignalUrl}/tradingview-alert/signal/{UserCode}/{accountNumber}/";

            var response = Http.Get(url);

            if (response.IsSuccessful)
            {
                var resultJson = JsonSerializer.Deserialize<SignalResponse>(response.Body);
                Print($"detail: {resultJson.detail}");
                Print($"signal_type: {resultJson.signal_type}");
                Print($"sl_price: {resultJson.sl_price}");
                Print($"tp_price: {resultJson.tp_price}");
                bool openTrade = resultJson.detail;
                string signalType = resultJson.signal_type;
                string symbol = resultJson.symbol;
                double amountToRisk = resultJson.amount_to_risk;
                double slPips = resultJson.sl_pips;
                double slPrice = resultJson.sl_price;
                double tpPips = resultJson.tp_pips;
                double tpPrice = resultJson.tp_price;
                
                // Abrimos operacion
                if (openTrade)
                {
                    
                    if (signalType == "buy")
                    {
                        double entryPrice = Symbols.GetSymbol(SymbolName).Ask;
                        
                        double lotSize = CalculateLotSize(SymbolName, amountToRisk, slPips, slPrice);
                        Print("lotSize: ", lotSize);
                        double volume = Symbol.QuantityToVolumeInUnits(lotSize);
                        Print("volume: ", volume);
                        var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, volume, positionLabel, slPips,);
                    }
                }
                

                return ;
            }
        }
        

        public double CalculateLotSize(string symbolCode, double riskAmount, double slPips, double slPrice)
        {
            var symbol = Symbols.GetSymbol(symbolCode);
            double pipValue = symbol.PipValue;
            Print("pipValue: ", pipValue);
        
            double lotSize = 0.0;
            if (slPrice > 0.0)
            {
                double symbolBid = symbol.Bid;
                double pointSize = symbol.PipSize;
                
                // cAlgo no tiene una función directa como MathAbs, pero el equivalente en C# es Math.Abs
                lotSize = riskAmount / (Math.Abs(symbolBid - slPrice) / pointSize * pipValue);
            }
            else if (slPips > 0.0)
            {
                // En cAlgo, el valor por pip debe ser ajustado dependiendo de si el USD es la moneda base o de cotización, y del tamaño del lote
                lotSize = riskAmount / (slPips * pipValue);
            }
            
            // No hay una función NormalizeDouble en cAlgo, pero podemos lograr una precisión de 2 dígitos con Math.Round
            return Math.Round(lotSize / 100000, 2);
        }
        
         // Function to calculate the SL pips
        public double CalculateSLPips(string symbol, double currentPrice, double slPrice, bool isBuyOrder)
        {
            // Get symbol information
            SymbolInfo symbolInfo = Symbols.GetSymbol(symbol);
    
            // Calculate pip size
            double pipSize = symbolInfo.PipSize;
    
            // If it's a buy trade
            if (isBuyOrder)
            {
                // Calculate the SL pips for a buy trade
                double slPips = (currentPrice - slPrice) / pipSize;
                return slPips;
            }
            // If it's a sell trade
            else
            {
                // Calculate the SL pips for a sell trade
                double slPips = (slPrice - currentPrice) / pipSize;
                return slPips;
            }
        }
        
        // Función para calcular el precio de take profit
        public double CalculateTPPrice(string symbol, double currentPrice, double tpPips, double tpPrice, bool isBuyOrder)
        {
            if (tpPrice > 0.0) return tpPrice;
            if (tpPips <= 0.0) return 0;
            
            // Obtenemos la información del símbolo
            Symbol symbolInfo = Symbols.GetSymbol(symbol);
    
            // Calculamos el tamaño de un pip
            double pipSize = symbolInfo.PipSize;
    
            // Si es una operación de compra
            if (isBuyOrder)
            {
                // Calculamos el precio de stop loss para una operación de compra
                double slPriceResult = currentPrice + (tpPips * pipSize);
                return slPriceResult;
            }
            // Si es una operación de venta
            else
            {
                // Calculamos el precio de stop loss para una operación de venta
                double slPriceResult = currentPrice - (tpPips * pipSize);
                return slPriceResult;
            }
        }


        private void SendTelegramMessage(string message)
        {
            try
            {
                var url = $"https://api.telegram.org/bot{TelegramBotToken}/sendMessage";
                
                // Crea el objeto de solicitud
                var request = WebRequest.Create(url);
                request.Method = "POST";
                request.ContentType = "application/json";
        
                // Crea el cuerpo del mensaje
                string postData = "{\"chat_id\":\"" + TelegramChatID + "\", \"text\":\"" + message + "\"}";
                
                // Envía el cuerpo del mensaje
                using (var streamWriter = new StreamWriter(request.GetRequestStream()))
                {
                    streamWriter.Write(postData);
                }
                
                // Recibe la respuesta
                var response = (HttpWebResponse)request.GetResponse();
                using (var streamReader = new StreamReader(response.GetResponseStream()))
                {
                    var result = streamReader.ReadToEnd();
                    Print("Respuesta de Telegram: ", result);
                }
            }
            catch (Exception e)
            {
                Print("Error al enviar mensaje a Telegram: ", e.Message);
            }
        }

        private bool BotAccessValidation(string accountNumber)
        {
            string url = $"{BotAccessUrl}/access-validation/{UserCode}/{accountNumber}/tradingview_alert_bot_enabled/";

            var response = Http.Get(url);

            if (response.IsSuccessful)
            {
                var resultJson = JsonSerializer.Deserialize<BotAccessResponse>(response.Body);
                Print($"ResultJson: {resultJson.result}");
                return resultJson.result;
            }
            return false;
        }

        private bool HasOpenedTradeToday(string symbol)
        {
            // Obtiene la fecha actual en UTC
            DateTime today = Server.Time.Date;

            // Itera a través de todas las posiciones abiertas
            foreach (var position in Positions)
            {
                // Verifica si la posición corresponde al símbolo objetivo y fue abierta hoy
                if (position.SymbolName== symbol && position.EntryTime.Date == today)
                {
                    return true; // Retorna verdadero si encuentra una coincidencia
                }
            }

            // Retorna falso si no se encuentra ninguna operación que coincida con los criterios
            return false;
        }

        // Esta función determina la diferencia horaria actual entre UTC y Nueva York
        private int GetNyOffset()
        {
            // Nueva York está en la zona horaria UTC-5 pero cambia a UTC-4 durante el horario de verano
            var nyTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
            var nyCurrentTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, nyTimeZoneInfo);
            return -nyTimeZoneInfo.GetUtcOffset(nyCurrentTime).Hours;
        }
    }

    public class BotAccessResponse
    {
        public bool result { get; set; }
    }

    public class SignalResponse
    {
        public bool detail { get; set; }
        public string signal_type { get; set; }
        public string symbol { get; set; }
        public double amount_to_risk { get; set; }
        public double sl_pips  { get; set; }
        public double sl_price { get; set; }
        public double tp_pips { get; set; }
        public double tp_price { get; set; }
    }
}
